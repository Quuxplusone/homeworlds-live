// unpackSummary.js
//
// as you would expect, it unpacks a game summary generated by my algorithm on the server

import GameState from './gameState.mjs';

function unpackSummary(players, summary) {
	let currentState = new GameState(players);
	let history = [[currentState]];
	let winner = null;
	// read from the summary
	const lines = summary.split("\n");
	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];
		// we already know the players
		if (line.substring(0, 8) === "Players:") {
			continue;
		}
		// the winner would be nice to know
		if (line.substring(0, 7) === "Winner:") {
			// get everything after the first space
			// Winner: bob
			winner = line.split(" ")[1];
			continue;
		}
		// ignore blank lines
		if (line.trim().length === 0) {
			continue;
		}
		
		// otherwise assume it is a turn
		const turnActions = line.split(";");
		for (let j = 0; j < turnActions.length; j++) {
			const parts = turnActions[j].split(",");
			// convert build/move/catastrophe systems to numbers
			if (parts[0] === "b" || parts[0] === "m" || parts[0] === "c") {
				parts[2] = Number(parts[2]);
			}
			
			// it is already in the correct order for doAction()
			const actionMethod = {
				h: "doHomeworld",
				b: "doBuild",
				t: "doTrade",
				m: "doMove",
				d: "doDiscovery",
				x: "doSteal",
				s: "doSacrifice",
				c: "doCatastrophe",
				e: "manuallyEliminatePlayer",
			}[parts[0]];
			
			if (!actionMethod) {
				console.warn("Bad action!", parts, "\nline was:", line);
			}
			
			const params = parts.slice(1);
			// for some reason, catastrophe and eliminate do not ask for the current player's turn
			if (parts[0] !== "c" && parts[0] !== "e") {
				params.unshift(currentState.turn);
			}
			
			try {
				const newState = currentState[actionMethod].apply(currentState, params);
				history[history.length - 1].push(newState);
				currentState = newState;
			} catch (error) {
				// end it here and display the error
				return {
					// all the normal data
					history: history,
					currentState: currentState,
					winner: winner,
					
					error: `There is a problem with that game archive! The action stuck was: ${actionMethod} ${params.join(", ")}. The error message was: ${error.message}. (This could be a bug.)`,
				};
			}
		}
		// now end the turn
		try {
			const endTurnState = currentState.doEndTurn();
			history.push([endTurnState]);
			currentState = endTurnState;
		} catch (error) {
			return {
				history: history,
				currentState: currentState,
				winner: winner,
				
				error: `There is a problem with that game archive! Something happened at the end of ${currentState.turn}'s turn: ${error.message}. (This could be a bug.)`,
			};
		}
	}
	
	// now return everything
	return {
		history: history,
		currentState: currentState,
		winner: winner,
		error: null
	};
}

export default unpackSummary;